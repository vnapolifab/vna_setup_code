import tkinter as tk
from tkinter import ttk, messagebox
import os
import numpy as np
import ast
import json
import tkinter.font as tkFont
from CONSTANTS import *

from library_misc import *

"""
Code for the GUI used in the measurement script.
"""


class ParameterInputGUI:
    def __init__(self, root):
        self.root = root
        self.settings = None
        self.setup_gui()
    
    def list_user_folders(self, data_folder):
        try:
            folders = [folder for folder in os.listdir(data_folder)
                       if os.path.isdir(os.path.join(data_folder, folder))]
        except FileNotFoundError:
            messagebox.showerror("Folder Not Found", f"The '{data_folder}' folder does not exist.")
            folders = []
        return folders
    
    
    def parse_field_sweep(self, field_sweep_str):
        """
        Parse the field sweep input string to a NumPy array.

        Parameters:
        - field_sweep_str: A string representation of a list of numbers, e.g., "1, 2, 3" or using range notation "1:1:5".

        Returns:
        - A list of the numbers in the input string or generated by the range notation.
        """
        try:
            # Check if the input string uses range notation (e.g., "1:1:5")
            if ':' in field_sweep_str:
                # Split the string by ':' to get start, step, stop values
                start, step, stop = map(float, field_sweep_str.split(':'))
                # Use range to generate the list of numbers
                field_sweep_list = list(np.arange(start, stop + 0.00001, step))  # +0.00001 fa includere il numero finale, TODO trovare un modo migliore per includerlo
            else:
                # For comma-separated values, convert string to list of integers
                # Handle both with and without brackets
                if not field_sweep_str.startswith('['):
                    field_sweep_str = f'[{field_sweep_str}]'
                field_sweep_list = ast.literal_eval(field_sweep_str)
                # Ensure the result is a list of floats
                field_sweep_list = list(np.array(field_sweep_list).astype(float))
            
            for i in range(len(field_sweep_list)):
                field_sweep_list[i] = ( np.round(field_sweep_list[i] *10**10)/10**10 )
            
            return field_sweep_list
        except (ValueError, SyntaxError) as e:
            return None
    

    def save_settings(self):    
        """
        Save the current settings to a file.
        """
        settings_file = os.path.join(os.path.dirname(__file__), "last_settings.json")
        with open(settings_file, "w") as f:
            json.dump(self.settings, f, indent=4)
        # messagebox.showinfo("Settings Saved", "The settings have been saved successfully.")    
    

    def load_last_settings(self):
        """
        Load settings from a file and update the GUI fields accordingly.
        """
        settings_file = os.path.join(os.path.dirname(__file__), "last_settings.json")
        try:
            with open(settings_file, "r") as f:
                settings = json.load(f)
                settings["start_frequency"] = settings["start_frequency"] / 10**9    # From Hz to GHz
                settings["stop_frequency"]  = settings["stop_frequency"] / 10**9 
            
                # Now, set the GUI fields with these settings
                self.user_name_var.set(settings.get('user_name', ''))
                self.measurement_name_entry.delete(0, tk.END)
                self.measurement_name_entry.insert(0, settings.get('measurement_name', ''))
                self.description_entry.delete(0, tk.END)
                self.description_entry.insert(0, settings.get('description', ''))
                self.dipole_mode_combo.set(self.dipole_mode_mapping_inv[settings.get('dipole_mode', '')])
                self.s_parameter_var.set(settings.get('s_parameter', 'S11'))
                self.field_sweep_entry.delete(0, tk.END)
                self.field_sweep_entry.insert(0, str(settings.get('field_sweep', '[]')))
                self.angle_entry.delete(0, tk.END)
                self.angle_entry.insert(0, str(settings.get('angle', '')))
                self.start_freq_entry.delete(0, tk.END)
                self.start_freq_entry.insert(0, str(settings.get('start_frequency', '')))
                self.stop_freq_entry.delete(0, tk.END)
                self.stop_freq_entry.insert(0, str(settings.get('stop_frequency', '')))
                self.num_points_entry.delete(0, tk.END)
                self.num_points_entry.insert(0, str(int(settings.get('number_of_points', ''))))
                self.bandwidth_entry.delete(0, tk.END)
                self.bandwidth_entry.insert(0, str(settings.get('bandwidth', '')))
                self.power_entry.delete(0, tk.END)
                self.power_entry.insert(0, str(settings.get('power', '')))
                self.ref_entry.delete(0, tk.END)
                self.ref_entry.insert(0, str(settings.get("ref_field", 0)))
                
                messagebox.showinfo("Settings Loaded", "The settings have been loaded successfully.")
        except FileNotFoundError:
            messagebox.showerror("Settings Not Found", "No saved settings found.")


    def load_any_settings(self):
        """
        Load settings from a file and update the GUI fields accordingly.
        """

        user_folder, measurement_folder = gui_folder_selection(func_on_submit=lambda x:x)
        settings_file = os.path.join(os.path.dirname(__file__), "DATA", f"{user_folder}", f"{measurement_folder}", "measurement_info.json")

        try:
            with open(settings_file, "r") as f:
                settings = json.load(f)
                settings["start_frequency"] = settings["start_frequency"] / 10**9    # From Hz to GHz
                settings["stop_frequency"]  = settings["stop_frequency"] / 10**9 
            
                # Now, set the GUI fields with these settings
                self.user_name_var.set(settings.get('user_name', ''))
                self.measurement_name_entry.delete(0, tk.END)
                self.sample_name_var.set(settings.get('sample_name', ''))
                self.measurement_name_entry.insert(0, settings.get('measurement_name', ''))
                self.description_entry.delete(0, tk.END)
                self.description_entry.insert(0, settings.get('description', ''))
                self.dipole_mode_combo.set(self.dipole_mode_mapping_inv[settings.get('dipole_mode', '')])
                self.s_parameter_var.set(settings.get('s_parameter', 'S11'))
                self.field_sweep_entry.delete(0, tk.END)
                self.field_sweep_entry.insert(0, str(settings.get('field_sweep', '[]')))
                self.angle_entry.delete(0, tk.END)
                self.angle_entry.insert(0, str(settings.get('angle', '')))
                self.start_freq_entry.delete(0, tk.END)
                self.start_freq_entry.insert(0, str(settings.get('start_frequency', '')))
                self.stop_freq_entry.delete(0, tk.END)
                self.stop_freq_entry.insert(0, str(settings.get('stop_frequency', '')))
                self.num_points_entry.delete(0, tk.END)
                self.num_points_entry.insert(0, str(int(settings.get('number_of_points', ''))))
                self.bandwidth_entry.delete(0, tk.END)
                self.bandwidth_entry.insert(0, str(settings.get('bandwidth', '')))
                self.power_entry.delete(0, tk.END)
                self.power_entry.insert(0, str(settings.get('power', '')))
                self.ref_entry.delete(0, tk.END)
                self.ref_entry.insert(0, str(settings.get("ref_field", 0)))
                
                messagebox.showinfo("Settings Loaded", "The settings have been loaded successfully.")
        except FileNotFoundError:
            messagebox.showerror("Settings Not Found", "No saved settings found.")


    def submit(self):
        user_name = self.user_name_var.get() if self.user_name_var.get() != "New User" else self.new_user_entry.get()
        sample_name = self.sample_name_var.get() if self.sample_name_var.get() != "New User" else self.new_sample_entry.get()
        measurement_name = self.measurement_name_entry.get()

        if not user_name.strip() or not measurement_name.strip():
            messagebox.showerror("Invalid Input", "User name and measurement name cannot be blank.")
            return
        
        if self.parse_field_sweep(self.field_sweep_entry.get()) == None:
            messagebox.showerror("Invalid Input", "Field Sweep must be a valid list of numbers (e.g., '1, 2, 3') or a valid range notation (e.g., '1:1:5').")
            return

        self.settings = {
            'user_name': user_name,
            'sample_name': sample_name,
            'measurement_name': measurement_name,
            'description': self.description_entry.get(),
            'dipole_mode': self.dipole_mode_mapping[self.dipole_mode_var.get()],
            's_parameter': self.s_parameter_var.get(),
            'field_sweep': self.parse_field_sweep(self.field_sweep_entry.get()),
            'angle': self.angle_entry.get(),
            'start_frequency': self.start_freq_entry.get(),
            'stop_frequency': self.stop_freq_entry.get(),
            'number_of_points': self.num_points_entry.get(),
            'bandwidth': self.bandwidth_entry.get(),
            'power': self.power_entry.get(),
            'ref_field': self.ref_entry.get()
        }

        for key in ['angle', 'start_frequency', 'stop_frequency', 'bandwidth', 'power']:
            try:
                self.settings[key] = float(self.settings[key])
            except ValueError:
                messagebox.showerror("Invalid Input", f"Please enter a valid number for {key.replace('_', ' ')}")
                return
        
        for key in ['number_of_points']:
            try:
                self.settings[key] = int(self.settings[key])
            except ValueError:
                messagebox.showerror("Invalid Input", f"Please enter a valid number for {key.replace('_', ' ')}")
                return

        self.settings["start_frequency"] = self.settings["start_frequency"] * 10**9   # From GHz to Hz conversion
        self.settings["stop_frequency"]  = self.settings["stop_frequency"] * 10**9

        self.save_settings()  # Call save_settings to save the inputs
        self.root.quit()  # Close the GUI

    
    def on_user_change_user(self, event):
        if self.user_name_var.get() == "New User":
            self.new_user_entry.grid(row=1, column=1, sticky="ew", padx=5, pady=5)
        else:
            self.new_user_entry.grid_remove()

        self.sample_name_combo["values"] = ["New sample"] + self.list_user_folders(os.path.join(DATA_FOLDER_NAME, self.user_name_var.get()))
        

    def on_user_change_sample(self, event):
        if self.sample_name_var.get() == "New sample":
            self.new_sample_entry.grid(row=3, column=1, sticky="ew", padx=5, pady=5)
        else:
            self.new_sample_entry.grid_remove()

    def on_user_change_dipole(self, event):
        if self.dipole_mode_var.get() == self.dipole_mode_mapping_inv[2]:
            self.angle_entry.grid(row=5, column=1, sticky="ew", padx=5, pady=5)
            self.angle_entry_label.grid(row=5, column=0, sticky="w", padx=5, pady=5)
        else:
            self.angle_entry.grid_remove()
            self.angle_entry_label.grid_remove()
    

    def clear_fields(self):
        # Option 1: Clear the fields entirely
        self.new_user_entry.delete(0, tk.END)
        self.measurement_name_entry.delete(0, tk.END)
        self.field_sweep_entry.delete(0, tk.END)
        self.angle_entry.delete(0, tk.END)
        self.start_freq_entry.delete(0, tk.END)
        self.stop_freq_entry.delete(0, tk.END)
        self.num_points_entry.delete(0, tk.END)
        self.bandwidth_entry.delete(0, tk.END)
        self.power_entry.delete(0, tk.END)


    def setup_gui(self):
        self.root.title("Parameter Input GUI")
        self.root.geometry("750x800")

        data_folder = os.path.join(os.path.dirname(__file__), DATA_FOLDER_NAME)
        user_names = ["New User"] + self.list_user_folders(data_folder)

        self.user_name_var = tk.StringVar()
        self.sample_name_var = tk.StringVar()
        self.dipole_mode_var = tk.StringVar(value='1: Single dipole, flat head (on dipole 1)')
        self.s_parameter_var = tk.StringVar(value="S11")

        
        # Styling
        style = ttk.Style()
        style.theme_use('clam')

        style.configure('TLabel', font=('Helvetica', 12))
        style.configure('TEntry', font=('Helvetica', 12), padding=5, highlightthickness=0)
        style.configure('TButton', font=('Helvetica', 12), padding=5)
        style.configure('TCombobox', font=('Helvetica', 12), padding=5)
        style.map('TCombobox', fieldbackground=[('readonly', 'lightgrey')], selectbackground=[('readonly', 'lightgrey')], selectforeground=[('readonly', 'black')])
        style.map('TEntry', fieldbackground=[('!disabled', 'white'), ('disabled', 'grey')])

        self.root.configure(bg='light grey')

        # Default values
        self.default_values = {
            'user_name': "",
            'sample_name': "",
            'measurement_name': "",
            'dipole_mode': '1: Single dipole, flat head (on dipole 1)',
            's_parameter': "S14",
            'field_sweep': "10:10:100",
            'angle': "0",
            'start_frequency': "1",
            'stop_frequency': "10",
            'number_of_points': "1001",
            'bandwidth': "500",
            'power': "-10"
        }

        self.dipole_mode_mapping = {
            '1: Single dipole, flat head (on dipole 1)': 1,
            '2: Quadrupole': 2,
            '3: Single dipole, round head 1': 3,
            '4: Single dipole, round head 2': 4
        }

        self.dipole_mode_mapping_inv = {v: k for k, v in self.dipole_mode_mapping.items()}


        # Input parameters
        ttk.Label(self.root, text="User", background='light grey').grid(row=0, column=0, sticky="w", padx=5, pady=5)
        self.user_name_combo = ttk.Combobox(self.root, textvariable=self.user_name_var, values=user_names, state="readonly", width=50)
        self.user_name_combo.grid(row=0, column=1, sticky="ew", padx=5, pady=5)
        self.user_name_combo.bind('<<ComboboxSelected>>', self.on_user_change_user)

        self.new_user_entry = ttk.Entry(self.root, width=50)

        ttk.Label(self.root, text="Sample", background='light grey').grid(row=2, column=0, sticky="w", padx=5, pady=5)
        self.sample_name_combo = ttk.Combobox(self.root, textvariable=self.sample_name_var, state="readonly", width=50)
        self.sample_name_combo.grid(row=2, column=1, sticky="ew", padx=5, pady=5)
        self.sample_name_combo.bind('<<ComboboxSelected>>', self.on_user_change_sample)

        self.new_sample_entry = ttk.Entry(self.root, width=50)

        ttk.Label(self.root, text="Measurement Name", background='light grey').grid(row=4, column=0, sticky="w", padx=5, pady=5)
        self.measurement_name_entry = ttk.Entry(self.root, width=50)
        self.measurement_name_entry.grid(row=4, column=1, sticky="ew", padx=5, pady=5)

        ttk.Label(self.root, text="Description (optional)", background='light grey').grid(row=5, column=0, sticky="w", padx=5, pady=5)
        self.description_entry = ttk.Entry(self.root, width=50)
        self.description_entry.grid(row=5, column=1, sticky="ew", padx=5, pady=5)

        ttk.Label(self.root, text="Dipole Mode", background='light grey').grid(row=6, column=0, sticky="w", padx=5, pady=5)
        self.dipole_mode_combo = ttk.Combobox(self.root, textvariable=self.dipole_mode_var, values=[
            self.dipole_mode_mapping_inv[1], 
            self.dipole_mode_mapping_inv[2], 
            self.dipole_mode_mapping_inv[3], 
            self.dipole_mode_mapping_inv[4], 
        ], state="readonly", width=50)
        self.dipole_mode_combo.grid(row=6, column=1, sticky="ew", padx=5, pady=5)
        self.dipole_mode_combo.bind('<<ComboboxSelected>>', self.on_user_change_dipole)

        self.angle_entry_label = ttk.Label(self.root, text="Angle [deg]", background='light grey')
        self.angle_entry = ttk.Entry(self.root, width=50, textvariable=tk.StringVar(value=self.default_values['angle']))
        self.angle_entry.insert(0, self.default_values["angle"])    

        ttk.Label(self.root, text="S-parameter", background='light grey').grid(row=8, column=0, sticky="w", padx=5, pady=5)
        self.s_parameter_combo = ttk.Combobox(self.root, textvariable=self.s_parameter_var, values=["S11", "S12", "S13", "S14","S21", "S22", "S23", "S24","S31", "S32", "S33", "S34","S41", "S42", "S43", "S44"], state="readonly")
        self.s_parameter_combo.grid(row=8, column=1, sticky="ew", padx=5, pady=5)

        ttk.Label(self.root, text="Field Sweep [mT]", background='light grey').grid(row=9, column=0, sticky="w", padx=5, pady=5)
        self.field_sweep_entry = ttk.Entry(self.root)
        self.field_sweep_entry.insert(0, self.default_values["field_sweep"])
        self.field_sweep_entry.grid(row=9, column=1, sticky="ew", padx=5, pady=5)

        # Field swwwp notation explenation
        customFont = tkFont.Font(size=-12)  # Example size, adjust as needed. Negative sizes refer to pixel size.
        explanation_label = ttk.Label(self.root, text="Accepted formats:", background='light grey', font=customFont)
        explanation_label.grid(row=10, column=1, sticky="w", padx=5, pady=5)
        explanation_label = ttk.Label(self.root, text=" - val1, val2, val3, ...    Single values", background='light grey', font=customFont)
        explanation_label.grid(row=11, column=1, sticky="w", padx=5, pady=5)
        explanation_label = ttk.Label(self.root, text=" - start:step:stop    e.g.: 10:5:50 means 10 mT, 15 mT, 20 mT etc.", background='light grey', font=customFont)
        explanation_label.grid(row=12, column=1, sticky="w", padx=5, pady=5)

        ttk.Label(self.root, text="Start Frequency [GHz]", background='light grey').grid(row=15, column=0, sticky="w", padx=5, pady=5)
        self.start_freq_entry = ttk.Entry(self.root)
        self.start_freq_entry.insert(0, self.default_values["start_frequency"])    
        self.start_freq_entry.grid(row=15, column=1, sticky="ew", padx=5, pady=5)

        ttk.Label(self.root, text="Stop Frequency [GHz]", background='light grey').grid(row=16, column=0, sticky="w", padx=5, pady=5)
        self.stop_freq_entry = ttk.Entry(self.root)
        self.stop_freq_entry.insert(0, self.default_values["stop_frequency"])  
        self.stop_freq_entry.grid(row=16, column=1, sticky="ew", padx=5, pady=5)

        ttk.Label(self.root, text="Number of Frequency points", background='light grey').grid(row=17, column=0, sticky="w", padx=5, pady=5)
        self.num_points_entry = ttk.Entry(self.root)
        self.num_points_entry.insert(0, self.default_values["number_of_points"])  
        self.num_points_entry.grid(row=17, column=1, sticky="ew", padx=5, pady=5)

        ttk.Label(self.root, text="Bandwidth [Hz]", background='light grey').grid(row=18, column=0, sticky="w", padx=5, pady=5)
        self.bandwidth_entry = ttk.Entry(self.root)
        self.bandwidth_entry.insert(0, self.default_values["bandwidth"]) 
        self.bandwidth_entry.grid(row=18, column=1, sticky="ew", padx=5, pady=5)

        ttk.Label(self.root, text="Power [dBm]", background='light grey').grid(row=19, column=0, sticky="w", padx=5, pady=5)
        self.power_entry = ttk.Entry(self.root)
        self.power_entry.insert(0, self.default_values["power"])
        self.power_entry.grid(row=19, column=1, sticky="ew", padx=5, pady=5)

        ttk.Label(self.root, text="             --------------------------- Advanced settings ---------------------------", background='light grey').grid(row=25, column=0, columnspan=3, sticky="w", padx=5, pady=5)

        ttk.Label(self.root, text="Ref field [mT]", background='light grey').grid(row=26, column=0, sticky="w", padx=5, pady=5)
        self.ref_entry = ttk.Entry(self.root)
        self.ref_entry.insert(0, "0")
        self.ref_entry.grid(row=26, column=1, sticky="ew", padx=5, pady=5)
  

        # Buttons
        self.submit_button = ttk.Button(self.root, text="Submit", command=self.submit, width=20)
        self.submit_button.grid(row=30, column=1, columnspan=1, padx=10, pady=10)

        self.clear_button = ttk.Button(self.root, text="Clear", command=self.clear_fields, width=20)
        self.clear_button.grid(row=31, column=1, columnspan=1, padx=10, pady=(0, 10))

        self.load_last_settings_button = ttk.Button(self.root, text="Load Last Settings", command=self.load_last_settings, width=20)
        self.load_last_settings_button.grid(row=32, column=1, columnspan=1, padx=10, pady=(0, 10))

        self.load_any_settings_button = ttk.Button(self.root, text="Load Settings of a measure", command=self.load_any_settings, width=20)
        self.load_any_settings_button.grid(row=33, column=1, columnspan=1, padx=10, pady=(0, 10))



def gui():
    """
    Function that is invoked in other the measurement script to create the gui.
    """
    root = tk.Tk()
    app = ParameterInputGUI(root)
    root.mainloop()
    root.destroy()  # Ensure the root window is closed properly
    return app.settings if app.settings else None






def gui_folder_selection(func_on_submit):
    """
    Function to call the gui for folder selection. Used in gui damping and gui FMR.
    """

    # Get the list of all subfolders in the 'DATA' directory
    data_dir = os.path.join(os.getcwd(), 'DATA')
    subfolders = [f.name for f in os.scandir(data_dir) if f.is_dir()]

    # Create the root window
    root = tk.Tk()
    root.title('Folder Selector ff')
    root.geometry('550x200')  # Set the window size
    root.configure(bg='lightgrey')  # Set the background color

    # Styling
    style = ttk.Style()
    style.theme_use('clam')
    style.configure('TLabel', font=('Helvetica', 12))
    style.configure('TEntry', font=('Helvetica', 12), padding=5, highlightthickness=0)
    style.configure('TButton', font=('Helvetica', 12), padding=5)
    style.configure('TCombobox', font=('Helvetica', 12), padding=5)
    style.map('TCombobox', fieldbackground=[('readonly', 'lightgrey')], selectbackground=[('readonly', 'lightgrey')], selectforeground=[('readonly', 'black')])
    style.map('TEntry', fieldbackground=[('!disabled', 'white'), ('disabled', 'grey')])

    # Create StringVars to hold the selected folder's names
    user_ = tk.StringVar()
    sample = tk.StringVar()
    measure = tk.StringVar()

    # Create labels for the dropdown menus
    active_row = 0
    user_label = tk.Label(root, text='User:', bg='lightgrey', font=('Arial', 14))
    user_label.grid(column=0, row=active_row, padx=10, pady=10, sticky='e')

    active_row += 1
    sample_label = tk.Label(root, text='Sample:', bg='lightgrey', font=('Arial', 14))
    sample_label.grid(column=0, row=active_row, padx=10, pady=10, sticky='e')

    active_row += 1
    measure_label = tk.Label(root, text='Measure:', bg='lightgrey', font=('Arial', 14))
    measure_label.grid(column=0, row=active_row, padx=10, pady=10, sticky='e')

    # Create a dropdown menu with the subfolder names
    active_row=0
    user_dropdown = ttk.Combobox(root, textvariable=user_, state="readonly", width=50)
    user_dropdown['values'] = subfolders
    user_dropdown.grid(column=1, row=active_row, padx=10, pady=10)

    # Create a dropdown menu for the subfolders of the selected user folder
    active_row += 1
    sample_dropdown = ttk.Combobox(root, textvariable=sample, state="readonly", width=50)
    sample_dropdown.grid(column=1, row=active_row, padx=10, pady=10)

    # Create a dropdown menu for the subfolders of the selected user folder
    active_row += 1
    measure_dropdown = ttk.Combobox(root, textvariable=measure, state="readonly", width=50)
    measure_dropdown.grid(column=1, row=active_row, padx=10, pady=10)

    # Function to update the measure dropdown when a user folder is selected
    def user_selected(event):
        selected_user = user_.get()
        user_dir = os.path.join(data_dir, selected_user)
        samples = [f.name for f in os.scandir(user_dir) if f.is_dir()]
        sample_dropdown['values'] = samples
 
    # Function to print the selected measure folder's name when a selection is made
    def sample_selected(event):
        selected_user = user_.get()
        selected_sample = sample.get()
        sample_dir = os.path.join(data_dir, selected_user, selected_sample)
        print(sample_dir)
        measures = [f.name for f in os.scandir(sample_dir) if f.is_dir()]
        measure_dropdown['values'] = measures

    # Function to print the selected measure folder's name when a selection is made
    def measure_selected(event):
        selected_user = user_.get()
        selected_sample = sample.get()
        selected_measure = measure.get()
        settings = load_metadata(selected_user, selected_sample, selected_measure)
        printSettings(settings)

    # Bind the functions to the dropdown menus
    user_dropdown.bind("<<ComboboxSelected>>", user_selected)
    sample_dropdown.bind("<<ComboboxSelected>>", sample_selected)
    measure_dropdown.bind("<<ComboboxSelected>>", measure_selected)

    # Function to check submission validity and quit if valid
    def submit_action():
        if not user_.get() or not measure.get() or not sample.get():
            messagebox.showerror("Error", "Please select both a user and a measure before submitting.")
        else:
            # Call the analysis function instead of quitting
            func_on_submit(user_.get(), sample.get(), measure.get())

    # Create a submit button with a new command
    active_row += 1
    submit_button = tk.Button(root, text='Analysis', command=submit_action, font=('Arial', 14))
    submit_button.grid(column=1, row=active_row, padx=10, pady=10)

    # Start the GUI event loop
    root.mainloop()

    # Return the selected folder names
    return user_.get(), sample.get(), measure.get()


def printSettings(settings):
    print("*** Settings ***")
    for key in settings.keys():
        if key == "field_sweep":
            field_sweep = settings[key]
            field_sweep_truncated = []
            for field in field_sweep:
                field_sweep_truncated.append( np.round(field*10**10)/10**10 )
            settings[key] = field_sweep_truncated

        print(f"> {key} : {settings[key]}")
    print("\n")

# If this script is run directly (for testing), call gui() function
if __name__ == "__main__":
    settings = gui()
